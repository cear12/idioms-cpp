/*
    Example of Type Erasure idiom: a simple Any container.
    Allows storing any copyable type and retrieving it by type.
*/

#include <iostream>
#include <memory>
#include <typeinfo>
#include <typeindex>
#include <unordered_map>
#include <stdexcept>

// Non-templated base interface for erased types
class Any {
public:
    // Interface for the concrete holder
    struct IHolder {
        virtual ~IHolder() = default;
        virtual std::unique_ptr<IHolder> clone() const = 0;
        virtual const std::type_info& type() const = 0;
    };

    // Templated holder for concrete type T
    template<typename T>
    struct Holder : IHolder {
        Holder(const T& value) : value_(value) {}
        Holder(T&& value) : value_(std::move(value)) {}

        std::unique_ptr<IHolder> clone() const override {
            return std::make_unique<Holder<T>>(value_);
        }

        const std::type_info& type() const override {
            return typeid(T);
        }

        T value_;
    };

    // Default constructor creates empty Any
    Any() = default;

    // Construct from any copyable type
    template<typename T>
    Any(T value) : holder_(std::make_unique<Holder<T>>(std::move(value))) {}

    // Copy constructor clones the holder
    Any(const Any& other)
        : holder_(other.holder_ ? other.holder_->clone() : nullptr) {}

    // Copy assignment
    Any& operator=(const Any& other) {
        if (this != &other) {
            holder_ = other.holder_ ? other.holder_->clone() : nullptr;
        }
        return *this;
    }

    // Returns true if a value is stored
    bool hasValue() const noexcept {
        return holder_ != nullptr;
    }

    // Returns the stored type_info, or typeid(void) if empty
    const std::type_info& type() const noexcept {
        return holder_ ? holder_->type() : typeid(void);
    }

    // Cast back to the stored type, throws on mismatch
    template<typename T>
    T& cast() {
        if (!holder_ || holder_->type() != typeid(T)) {
            throw std::bad_cast();
        }
        return static_cast<Holder<T>*>(holder_.get())->value_;
    }

    template<typename T>
    const T& cast() const {
        if (!holder_ || holder_->type() != typeid(T)) {
            throw std::bad_cast();
        }
        return static_cast<const Holder<T>*>(holder_.get())->value_;
    }

private:
    std::unique_ptr<IHolder> holder_;
};

int main() {
    Any a = 42;                      // store int
    Any b = std::string("hello");    // store string

    std::cout << "Type of a: " << a.type().name() << "\n";
    std::cout << "Type of b: " << b.type().name() << "\n";

    // Retrieve values
    try {
        int iv = a.cast<int>();
        std::cout << "a contains int: " << iv << "\n";
    } catch (const std::bad_cast&) {
        std::cout << "Invalid cast for a\n";
    }

    try {
        std::string sv = b.cast<std::string>();
        std::cout << "b contains string: " << sv << "\n";
    } catch (const std::bad_cast&) {
        std::cout << "Invalid cast for b\n";
    }

    // Attempt wrong cast
    try {
        a.cast<std::string>();  // throws
    } catch (const std::bad_cast&) {
        std::cout << "Caught bad_cast as expected\n";
    }

    return 0;
}
