// Определяем структуру с функциями-указателями, имитирующими виртуальные функции
struct FakeVtable {
    void (*foo)();  // Указатель на функцию foo
};

// Реализуем функции, которые будут "виртуальными"
void BaseFoo() {
    std::cout << "Base::foo" << std::endl;
}

void DerivedFoo() {
    std::cout << "Derived::foo" << std::endl;
}

// Класс Base с "фейковой" виртуальной таблицей
class Base {
public:
    FakeVtable* vtable;  // Указатель на фейковую виртуальную таблицу

    Base() {
        vtable = new FakeVtable{&BaseFoo};  // Инициализация указателем на BaseFoo
    }

    // Вызов "виртуальной" функции через таблицу
    void foo() {
        vtable->foo();  // Вызов функции через фейковую таблицу
    }

    virtual ~Base() {
        delete vtable;
    }
};

// Класс Derived, который меняет указатель в фейковой vtable
class Derived : public Base {
public:
    Derived() {
        vtable->foo = &DerivedFoo;  // Переопределение функции foo
    }
};

int main() {
    Base* obj = new Derived();
    obj->foo();  // Вывод: "Derived::foo"

    delete obj;
}

/*
Производительность:

В некоторых системах накладные расходы на реальную виртуальную таблицу могут быть значительными. Использование "Fake Vtable" позволяет вручную управлять этим механизмом, исключая избыточные вызовы или дополнительные проверки.
Контроль над поведением:

"Fake Vtable" позволяет динамически управлять поведением программы, изменяя указатели на функции в момент выполнения. Это может быть полезно, если требуется особая логика переключения между различными функциями.
Упрощение ABI (Application Binary Interface):

В системах, где важно управлять бинарными интерфейсами, разработчики могут предпочесть использовать "Fake Vtable", чтобы более точно контролировать расположение функций в памяти.
Когда использовать?
Использование "Fake Vtable" может быть оправдано в высокопроизводительных системах, когда накладные расходы от стандартного полиморфизма недопустимы, или в тех случаях, когда необходимо иметь больше контроля над вызовами функций (например, в системах с низким уровнем, как в embedded-системах).

Идиома "Fake Vtable" в C++ позволяет реализовать полиморфизм и динамическое разрешение функций вручную, без использования встроенного механизма виртуальных функций. Это может быть полезно в определенных сценариях, где важно повысить производительность, уменьшить накладные расходы на виртуальные функции или иметь полный контроль над вызовами функций.
*/
